import sys 
path_prefix = '/home/changfenggroup/nrui/works/'
import time
# Make sure the test is performed on a single CPU core.
# We use the slurm to run this script which can only apply one core.
# import os
# os.environ[
#     "XLA_FLAGS"
# ] = "--xla_cpu_multi_thread_eigen=false  --xla_force_host_platform_device_count=1 intra_op_parallelism_threads=1"
# os.environ["OPENBLAS_NUM_THREADS"] = "1"
# os.environ["MKL_NUM_THREADS"] = "1"
# os.environ["OMP_NUM_THREADS"] = "1"

import numpy as np
import pandas as pd

import lal
import lalsimulation as lalsim
from lalsimulation import SimInspiralChooseFDWaveformSequence
import bilby

sys.path.append(f'{path_prefix}codes/gw_space/wf4ti')
sys.path.append('/home/hydrogen/workspace/Space_GW/wf4ti')
from wf4ti.waveforms.IMRPhenomD import IMRPhenomD as ti_IMRPhenomD
from wf4ti.constants import *
import taichi as ti
ti.init(arch=ti.cpu, default_fp=ti.f64, cpu_max_num_threads=1)

sys.path.append(f'{path_prefix}gw_software/WF4Py-master')
sys.path.append('/home/hydrogen/gw_software/WF4Py-master')
from WF4Py import waveforms as wf_py

sys.path.append(f'{path_prefix}gw_software/ripple-main/src')
sys.path.append('/home/hydrogen/gw_software/ripple-main/src')
import jax
import jax.numpy as jnp
jax.config.update("jax_enable_x64", True)
jax.config.update('jax_platform_name', 'cpu')
x = jnp.square(2)
print(repr(x.device_buffer.device()))
print(jax.devices())
print(jax.local_device_count())
from ripple.waveforms import IMRPhenomD

from bbhx.waveforms.phenomhm import PhenomHMAmpPhase

# set max_mass to avoid too many 0 at the end of waveform
minimum_frequency = 1e-5
maximum_frequency = 1e-1
f_cut = 0.2
max_mass = maximum_frequency/f_cut/MTSUN_SI
# print(max_mass)

num_tests = 10
rng = np.random.default_rng()
parameters = {}
parameters['total_mass'] = rng.uniform(1e3, max_mass, num_tests)
parameters['mass_ratio'] = rng.uniform(0.2, 1.0, num_tests)
parameters['chi_1'] = rng.uniform(-1.0, 1.0, num_tests)
parameters['chi_2'] = rng.uniform(-1.0, 1.0, num_tests)
parameters['luminosity_distance'] = rng.uniform(1000.0, 10000.0, num_tests)
parameters['inclination'] = rng.uniform(0, np.pi, num_tests)
parameters['reference_phase'] = rng.uniform(0, 2*np.pi, num_tests)
parameters['coalescence_time'] = np.zeros(num_tests)
parameters = bilby.gw.conversion.generate_mass_parameters(parameters)
parameters = pd.DataFrame(parameters)
# print(parameters.keys())
# print(parameters)
# for i in range(num_tests):
#     params = parameters.iloc[i]
#     fpeak = lalsim.IMRPhenomDGetPeakFreq(params['mass_1'],
#                                          params['mass_2'],
#                                          params['chi_1'],
#                                          params['chi_2'])
#     print(f'total mass: {params["total_mass"]}, peak frequency: {fpeak}')


extraParams = lal.CreateDict()
approximant = lalsim.GetApproximantFromString('IMRPhenomD')

time_consuming_ti = []
time_consuming_lal = []
time_consuming_py = []
time_consuming_ripple = []
time_consuming_bbhx = []
data_length_list = []


# NOTE: since different codes has different output form, some output amplitude and phase, 
# some output polarizations, the comparison maybe not absolutely fair.
# The output of wf4ti includes polarizations and tf which could be thought having the most 
# compution steps.
# For the code only return two polarization, we multiply a factor of 1.5
# for p in range(10, 30):
for p in range(10, 12):
    duration = 2**p
    cadance = 5
    f_array = np.arange(0, 1.0/(2*cadance), 1.0/duration)
    bound = ((f_array >= minimum_frequency) * (f_array <= maximum_frequency))
    f_array = f_array[bound]
    data_length = len(f_array)
    data_length_list.append(data_length)

    ##########################################################################################
    # waveform generated by wf4ti
    frequencies = ti.field(ti.f64, shape=(data_length,))
    frequencies.from_numpy(f_array)
    wf = ti_IMRPhenomD(frequencies, returned_form='polarizations', include_tf=True)
    wf.get_waveform(parameters.iloc[0])
    
    st = time.perf_counter()
    for i in range(num_tests):
        wf.get_waveform(parameters.iloc[i])
    ed = time.perf_counter()
    time_consuming = (ed - st)/num_tests
    print(f'ti {p}th, time:{time_consuming}')
    time_consuming_ti.append(time_consuming)

    ##########################################################################################
    # waveform generated by lalsim
    # remember export OMP_NUM_THREADS=1
    f_array_lal = lal.CreateREAL8Vector(data_length)
    f_array_lal.data = f_array

    st = time.perf_counter()
    for i in range(num_tests):
        plus_lal, cross_lal = SimInspiralChooseFDWaveformSequence(parameters.iloc[i]['reference_phase'], 
                                                                  parameters.iloc[i]['mass_1']*MSUN_SI, 
                                                                  parameters.iloc[i]['mass_2']*MSUN_SI, 
                                                                  0.0,
                                                                  0.0,
                                                                  parameters.iloc[i]['chi_1'], 
                                                                  0.0,
                                                                  0.0,
                                                                  parameters.iloc[i]['chi_2'], 
                                                                  0.0,
                                                                  parameters.iloc[i]['luminosity_distance']*1e6*PC_SI,
                                                                  parameters.iloc[i]['inclination'],
                                                                  extraParams, 
                                                                  approximant,
                                                                  f_array_lal
                                                                  )
    ed = time.perf_counter()
    # only return two polarization, a factor of 1.5 is multiplied
    time_consuming = 1.5 * (ed - st)/num_tests
    print(f'lalsim {p}th, time:{time_consuming}')
    time_consuming_lal.append(time_consuming)
    ##########################################################################################
    # waveform generated by wf4py
    wfclass_py = wf_py.IMRPhenomD()
    st = time.perf_counter()
    for i in range(num_tests):
        params_wf4py = {'Mc'    : np.asarray(parameters.iloc[i]['chirp_mass']),
                        'eta'   : np.asarray(parameters.iloc[i]['symmetric_mass_ratio']),
                        'chi1z' : np.asarray(parameters.iloc[i]['chi_1']),
                        'chi2z' : np.asarray(parameters.iloc[i]['chi_2']),
                        'iota'  : np.asarray(parameters.iloc[i]['inclination']),
                        'dL'    : np.asarray(parameters.iloc[i]['luminosity_distance'])/1000    # wf4py using the unit of Gpc
                        }
        amp_array_py = wfclass_py.Ampl(f_array, **params_wf4py)
        phase_array_py = wfclass_py.Phi(f_array, **params_wf4py)
    ed = time.perf_counter()
    # only return two polarization, a factor of 1.5 is multiplied
    time_consuming = 1.5 * (ed - st)/num_tests
    print(f'py {p}th, time:{time_consuming}')
    time_consuming_py.append(time_consuming)
    ##########################################################################################
    # waveform generated by ripple
    f_jnp_array = jnp.asarray(f_array)
    # print(f_jnp_array.shape)
    @jax.jit
    def waveform_ripple(theta):
        return IMRPhenomD.gen_IMRPhenomD_hphc(f_jnp_array, theta, f_jnp_array[0])

    theta_ripple = jnp.array([parameters.iloc[0]['chirp_mass'],
                              parameters.iloc[0]['symmetric_mass_ratio'],
                              parameters.iloc[0]['chi_1'],
                              parameters.iloc[0]['chi_2'],
                              parameters.iloc[0]['luminosity_distance'],
                              parameters.iloc[0]['coalescence_time'],
                              parameters.iloc[0]['reference_phase'],
                              parameters.iloc[0]['inclination']
                              ])
    hp, hc = waveform_ripple(theta_ripple)
    
    st = time.perf_counter()
    for i in range(num_tests):
        theta_ripple = jnp.array([parameters.iloc[i]['chirp_mass'],
                                  parameters.iloc[i]['symmetric_mass_ratio'],
                                  parameters.iloc[i]['chi_1'],
                                  parameters.iloc[i]['chi_2'],
                                  parameters.iloc[i]['luminosity_distance'],
                                  parameters.iloc[i]['coalescence_time'],
                                  parameters.iloc[i]['reference_phase'],
                                  parameters.iloc[i]['inclination']
                                  ])
        hp, hc = waveform_ripple(theta_ripple)
    ed = time.perf_counter()
    # only return two polarization, a factor of 1.5 is multiplied
    time_consuming = 1.5 * (ed - st)/num_tests
    print(f'ripple {p}th, time:{time_consuming}')
    time_consuming_ripple.append(time_consuming)

    ##########################################################################################
    # waveform generated by bbhx
    bbhx_wf = PhenomHMAmpPhase(use_gpu=False, run_phenomd=True)
    st = time.perf_counter()
    for i in range(num_tests):
        bbhx_wf(parameters.iloc[i]['mass_1'],
                parameters.iloc[i]['mass_2'],
                parameters.iloc[i]['chi_1'],
                parameters.iloc[i]['chi_2'],
                parameters.iloc[i]['luminosity_distance']*1e6*PC_SI,
                0.0,
                0.0,
                parameters.iloc[i]['coalescence_time'],
                data_length,
                freqs=f_array)
        amps = bbhx_wf.amp[0][0]  # shape (num_bin_all, num_modes, length)
        phase = bbhx_wf.phase[0][0]  # shape (num_bin_all, num_modes, length)
        tf = bbhx_wf.tf[0][0]
    ed = time.perf_counter()
    time_consuming = (ed - st)/num_tests
    print(f'bbhx {p}th, time:{time_consuming}')
    time_consuming_bbhx.append(time_consuming)

save_data = {'data_length': data_length_list,
             'ti': time_consuming_ti,
             'py': time_consuming_py,
             'lal': time_consuming_lal,
             'ripple': time_consuming_ripple,
             'bbhx': time_consuming_bbhx
            }

import json
with open('time_consuming.json', 'w') as f:
    json.dump(save_data, f)

with open('time_consuming.json', 'r') as f:
    save_data = json.load(f)


import matplotlib
from matplotlib import pyplot as plt
fig_width_pt = 3*246.0                  
inches_per_pt = 1.0/72.27               
golden_mean = (np.sqrt(5)-1.0)/2.0      
fig_width = fig_width_pt*inches_per_pt  
fig_height = fig_width*golden_mean      
fig_size =  [fig_width,fig_height]
params = {'axes.labelsize': 20,
          'font.family': 'serif',
          'font.serif': 'Computer Modern Raman',
          'font.size': 28,
          'legend.fontsize': 20,
          'xtick.labelsize': 18,
          'ytick.labelsize': 18,
          'axes.grid' : True,
          'text.usetex': False,
          'savefig.dpi' : 300,
          'lines.markersize' : 18,
          'figure.figsize': fig_size}
matplotlib.rcParams.update(params)
fig, ax = plt.subplots()
ax.loglog(save_data['data_length'], save_data['ti'],     label='wf4ti')
ax.loglog(save_data['data_length'], save_data['py'],     label='wf4py')
ax.loglog(save_data['data_length'], save_data['lal'],    label='lalsim')
ax.loglog(save_data['data_length'], save_data['ripple'], label='ripple')
ax.loglog(save_data['data_length'], save_data['bbhx'],   label='bbhx')
ax.legend()
fig.savefig('perf_cpu.png')

