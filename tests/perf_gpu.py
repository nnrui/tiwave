import sys 
sys.path.append('/home/hydrogen/workspace/Space_GW/wf4ti')
import time
import taichi as ti
# ti.init(arch=ti.cpu, default_fp=ti.f64, cpu_max_num_threads=1)
ti.init(arch=ti.gpu, default_fp=ti.f64)

import numpy as np
from matplotlib import pyplot as plt
import pandas as pd


import lal
import lalsimulation as lalsim
from lalsimulation import SimInspiralChooseFDWaveformSequence
import bilby

from wf4ti.waveforms.IMRPhenomD import IMRPhenomD
from wf4ti.constants import *


rng = np.random.default_rng()
parameters = {}
parameters['total_mass'] = rng.uniform(5.0, 30.0, 100)
parameters['mass_ratio'] = rng.uniform(0.2, 1.0, 100)
parameters['chi_1'] = rng.uniform(-1.0, 1.0, 100)
parameters['chi_2'] = rng.uniform(-1.0, 1.0, 100)
parameters['luminosity_distance'] = rng.uniform(100.0, 500.0, 100)
parameters['inclination'] = rng.uniform(0, np.pi, 100)
parameters['reference_phase'] = rng.uniform(0, 2*np.pi, 100)
parameters['coalescence_time'] = np.zeros(100)
parameters = pd.DataFrame(parameters)
parameters['mass_1'] = parameters['total_mass'] / (1+parameters['mass_ratio'])
parameters['mass_2'] = parameters['total_mass'] - parameters['mass_1'] 
# print(parameters)

extraParams = lal.CreateDict()
approximant = lalsim.GetApproximantFromString('IMRPhenomD')
minimum_frequency = 20.0
maximum_frequency = 1024.0

time_consuming_ti = []
time_consuming_lal = []
for p in range(12):
    duration = 2**p
    cadance = 1/2048
    f_array = np.arange(0, 1.0/(2*cadance), 1.0/duration)
    bound = ((f_array >= minimum_frequency) * (f_array <= maximum_frequency))
    f_array = f_array[bound]
    data_length = len(f_array)

    # waveform generated by wf4ti
    frequencies = ti.field(ti.f64, shape=(data_length,))
    frequencies.from_numpy(f_array)
    wf = IMRPhenomD(frequencies, returned_form='polarizations', include_tf=False)
    wf.get_waveform(parameters.iloc[0])
    st = time.perf_counter()
    for i in range(10):
        wf.get_waveform(parameters.iloc[i])
    ed = time.perf_counter()
    time_consuming = (ed - st)/10
    print(f'ti {p}th, time:{time_consuming}')
    time_consuming_ti.append(time_consuming)


    # waveform generated by lalsim
    f_array_lal = lal.CreateREAL8Vector(data_length)
    f_array_lal.data = f_array
    st = time.perf_counter()
    for i in range(10):
         plus_lal, cross_lal = SimInspiralChooseFDWaveformSequence(parameters.iloc[i]['reference_phase'], 
                                                                   parameters.iloc[i]['mass_1']*MSUN_SI, 
                                                                   parameters.iloc[i]['mass_2']*MSUN_SI, 
                                                                   0.0,
                                                                   0.0,
                                                                   parameters.iloc[i]['chi_1'], 
                                                                   0.0,
                                                                   0.0,
                                                                   parameters.iloc[i]['chi_2'], 
                                                                   0.0,
                                                                   parameters.iloc[i]['luminosity_distance']*1e6*PC_SI,
                                                                   parameters.iloc[i]['inclination'],
                                                                   extraParams, 
                                                                   approximant,
                                                                   f_array_lal
                                                                   )
    ed = time.perf_counter()
    time_consuming = (ed - st)/10
    print(f'lal {p}th, time:{time_consuming}')
    time_consuming_lal.append(time_consuming)

plt.figure()
plt.plot(range(12), time_consuming_ti, label='ti')
plt.plot(range(12), time_consuming_lal, label='lal')
plt.legend()
plt.savefig('perf_comparing_gpu.png')
# plus_lal, cross_lal = SimInspiralChooseFDWaveformSequence(parameters['reference_phase'], 
#                                                    parameters['mass_1']*MSUN_SI, 
#                                                    parameters['mass_2']*MSUN_SI, 
#                                                    0.0,
#                                                    0.0,
#                                                    parameters['chi_1'], 
#                                                    0.0,
#                                                    0.0,
#                                                    parameters['chi_2'], 
#                                                    0.0,
#                                                    parameters['luminosity_distance']*1e6*PC_SI,
#                                                    parameters['inclination'],
#                                                    extraParams, 
#                                                    approximant,
#                                                    f_array_lal
#                                                    )
# plus_array_lal = plus_lal.data.data
# cross_array_lal = cross_lal.data.data

# # visualizing the comparision
# fig, ax = plt.subplots()
# ax.loglog(f_array, np.abs(wf_array_ti['hcross']), label='wf4ti')
# ax.loglog(f_array, np.abs(cross_array_lal), linestyle='dashed', label='lalsim')
# ax.legend()
# ax.set_title('Amplitude corss')
# ax.set_xlabel('f(Hz)')
# ax.set_ylabel(r'$|h_{\times}(f)|$')
# fig.savefig('amplitude_cross.png')

# fig, ax = plt.subplots()
# ax.loglog(f_array, np.abs(np.abs(wf_array_ti['hcross'])-np.abs(cross_array_lal))/np.abs(cross_array_lal), linestyle='', marker='.', markersize=5)
# ax.set_title('Amplitude difference cross')
# ax.set_xlabel('f(Hz)')
# ax.set_ylabel('diff')
# fig.savefig('amplitude_cross_diff.png')

# fig, ax = plt.subplots()
# ax.loglog(f_array, np.abs(wf_array_ti['hplus']), label='wf4ti')
# ax.loglog(f_array, np.abs(plus_array_lal), linestyle='dashed', label='lalsim')
# ax.legend()
# ax.set_title('Amplitude plus')
# ax.set_xlabel('f(Hz)')
# ax.set_ylabel(r'$|h_{\times}(f)|$')
# fig.savefig('amplitude_plus.png')

# fig, ax = plt.subplots()
# ax.loglog(f_array, np.abs(np.abs(wf_array_ti['hplus'])-np.abs(plus_array_lal))/np.abs(plus_array_lal), linestyle='', marker='.', markersize=5)
# ax.set_title('Amplitude difference plus')
# ax.set_xlabel('f(Hz)')
# ax.set_ylabel('diff')
# fig.savefig('amplitude_plus_diff.png')

# # fig, ax = plt.subplots()
# # hcross_phase_ti = np.where(np.abs(np.exp(-1j*PI/4)*wf_array_ti['hcross'])>0.0, (np.exp(-1j*PI/4)*wf_array_ti['hcross']/np.abs(np.exp(1j*PI/4)*wf_array_ti['hcross'])).real, 0.0)
# # hcross_phase_lal = np.where(np.abs(cross_array_lal)>0.0, (cross_array_lal/np.abs(cross_array_lal)).real, 0.0)
# # ax.semilogx(f_array, hcross_phase_ti, label='wf4ti')
# # ax.semilogx(f_array, hcross_phase_lal, linestyle='dashed', label='lalsim')
# # ax.legend()
# # ax.set_title('cos phase cross')
# # ax.set_xlabel('f(Hz)')
# # ax.set_ylabel(r'$\cos \Psi_{\times}$')
# # ax.set_xlim(20, 100)
# # MRD_f_join = wf.phase_coefficients[None].phase_merge_ringdown_f_join/wf.source_parameters[None].M_sec
# # ins_f_join = 0.018/wf.source_parameters[None].M_sec
# # ax.axvline(MRD_f_join, color='tab:red')
# # ax.axvline(ins_f_join, color='tab:green')
# # print(MRD_f_join)
# # print(ins_f_join)
# # fig.savefig('cos_phase_cross.png')

# # fig, ax = plt.subplots()
# # ax.semilogx(f_array, np.abs((wf_array_ti['hcross']/np.abs(wf_array_ti['hcross'])).real - (cross_array_lal/np.abs(cross_array_lal)).real))
# # ax.set_title('cos phase cross diff')
# # ax.set_xlabel('f(Hz)')
# # ax.set_ylabel('diff')
# # fig.savefig('cos_phase_cross_diff.png')



# # comparing the amplituce_phase
# # this part requires the modified lalsuite (https://github.com/niuiniuin/lalsuite)
# wf = IMRPhenomD(frequencies, returned_form='amplitude_phase')
# wf.get_waveform(parameters)
# f_peak = wf.amplitude_coefficients[None].f_peak
# f_peak = f_peak/wf.source_parameters[None].M_sec
# wf = IMRPhenomD(frequencies, returned_form='amplitude_phase', reference_frequency=f_peak)
# wf.get_waveform(parameters)
# wf_array_ti = wf.np_array_of_waveform_container()

# # waveform generated by lalsim
# extraParams = lal.CreateDict()
# approximant = lalsim.GetApproximantFromString('IMRPhenomD')
# f_array_lal = lal.CreateREAL8Vector(data_length)
# f_array_lal.data = f_array
# amp_lal, phase_lal, tf_lal = lalsim.SimIMRPhenomDFrequencySequenceh22AmpPhasetf(f_array, 
#                                                                                 parameters['mass_1'], 
#                                                                                 parameters['mass_2'], 
#                                                                                 parameters['chi_1'], 
#                                                                                 parameters['chi_2'], 
#                                                                                 parameters['luminosity_distance'], 
#                                                                                 parameters['coalescence_time'], 
#                                                                                 0.0, 
#                                                                                 extraParams)
# amp_array_lal = amp_lal.data
# phase_array_lal = phase_lal.data
# tf_array_lal = tf_lal.data

# fig, ax = plt.subplots()
# ax.semilogx(f_array, -wf_array_ti['phase'], label='wf4ti')
# ax.semilogx(f_array, phase_array_lal, linestyle='dashed', label='lalsim')
# ax.legend()
# # ax.set_title('cos phase cross')
# # ax.set_xlabel('f(Hz)')
# # ax.set_ylabel(r'$\cos \Psi_{\times}$')
# # ax.set_xlim(20, 100)
# # MRD_f_join = wf.phase_coefficients[None].phase_merge_ringdown_f_join/wf.source_parameters[None].M_sec
# # ins_f_join = 0.018/wf.source_parameters[None].M_sec
# # ax.axvline(MRD_f_join, color='tab:red')
# # ax.axvline(ins_f_join, color='tab:green')
# # print(MRD_f_join)
# # print(ins_f_join)
# fig.savefig('phase.png')
