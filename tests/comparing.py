import sys 
sys.path.append('/home/hydrogen/workspace/Space_GW/wf4ti')
import time
import numpy as np
from matplotlib import pyplot as plt
import matplotlib
fig_width_pt = 3*246.0                  # Get this from LaTeX using \showthe\columnwidth
inches_per_pt = 1.0/72.27               # Convert pt to inch
golden_mean = (np.sqrt(5)-1.0)/2.0      # Aesthetic ratio
fig_width = fig_width_pt*inches_per_pt  # width in inches
fig_height = fig_width*golden_mean      # height in inches
fig_size =  [fig_width,fig_height]
params = {'axes.labelsize': 20,
          'font.family': 'serif',
          'font.serif': 'Computer Modern Raman',
          'font.size': 28,
          'legend.fontsize': 20,
          'xtick.labelsize': 18,
          'ytick.labelsize': 18,
          'axes.grid' : True,
          'text.usetex': True,
          'savefig.dpi' : 300,
          'lines.markersize' : 18,
          'figure.figsize': fig_size}
matplotlib.rcParams.update(params)

####################################################################################################
parameters = {}
parameters['total_mass'] = 50
parameters['mass_ratio'] = 0.8
parameters['chi_1'] = 0.2
parameters['chi_2'] = 0.3
parameters['luminosity_distance'] = 300.0
parameters['inclination'] = 0.15
parameters['reference_phase'] = 0.0
parameters['coalescence_time'] = 0.0

cadance = 1/2048
duration = 4
f_array = np.arange(0, 1.0/(2*cadance), 1.0/duration)
minimum_frequency = 20.0
maximum_frequency = 1024.0
bound = ((f_array >= minimum_frequency) * (f_array <= maximum_frequency))
f_array = f_array[bound]
data_length = len(f_array)

####################################################################################################
# waveform generated by wf4ti
import taichi as ti
ti.init(arch=ti.cpu, default_fp=ti.f64)
from wf4ti.waveforms.IMRPhenomD import IMRPhenomD
from wf4ti.constants import *

frequencies = ti.field(ti.f64, shape=(data_length,))
frequencies.from_numpy(f_array)
wf = IMRPhenomD(frequencies, returned_form='polarizations')
wf.get_waveform(parameters)
wf_array_ti = wf.np_array_of_waveform_container()

####################################################################################################
# waveform generated by lalsim
import lal
import lalsimulation as lalsim
from lalsimulation import SimInspiralChooseFDWaveformSequence
import bilby

parameters = bilby.gw.conversion.generate_all_bbh_parameters(parameters)
extraParams = lal.CreateDict()
approximant = lalsim.GetApproximantFromString('IMRPhenomD')
f_array_lal = lal.CreateREAL8Vector(data_length)
f_array_lal.data = f_array
plus_lal, cross_lal = SimInspiralChooseFDWaveformSequence(parameters['reference_phase'], 
                                                          parameters['mass_1']*MSUN_SI, 
                                                          parameters['mass_2']*MSUN_SI, 
                                                          0.0,
                                                          0.0,
                                                          parameters['chi_1'], 
                                                          0.0,
                                                          0.0,
                                                          parameters['chi_2'], 
                                                          0.0,
                                                          parameters['luminosity_distance']*1e6*PC_SI,
                                                          parameters['inclination'],
                                                          extraParams, 
                                                          approximant,
                                                          f_array_lal
                                                          )
plus_array_lal = plus_lal.data.data
cross_array_lal = cross_lal.data.data

####################################################################################################
# visualizing the comparision
# hcross
fig, ax = plt.subplots()
ax.loglog(f_array, np.abs(wf_array_ti['hcross']), label='wf4ti')
ax.loglog(f_array, np.abs(cross_array_lal), linestyle='dashed', label='lalsim')
ax.legend()
ax.set_title(r'Amplitude $h_{\times}$')
ax.set_xlabel(r'$f$(Hz)')
ax.set_ylabel(r'$|h_{\times}(f)|$')
fig.tight_layout()
fig.savefig('amplitude_cross.png')

fig, ax = plt.subplots()
hcross_phase_ti = np.where(np.abs(wf_array_ti['hcross'])>0.0, (wf_array_ti['hcross']/np.abs(wf_array_ti['hcross'])).real, 0.0)
hcross_phase_lal = np.where(np.abs(cross_array_lal)>0.0, (cross_array_lal/np.abs(cross_array_lal)).real, 0.0)
ax.semilogx(f_array, hcross_phase_ti, label='wf4ti')
ax.semilogx(f_array, hcross_phase_lal, linestyle='dashed', label='lalsim')
ax.legend()
ax.set_title(r'$\cos\Phi_\times$')
ax.set_xlabel(r'$f$(Hz)')
ax.set_ylabel(r'$\cos\Phi_{\times}$')
fig.savefig('cos_phase_cross.png')

# hplus
fig, ax = plt.subplots()
ax.loglog(f_array, np.abs(wf_array_ti['hplus']), label='wf4ti')
ax.loglog(f_array, np.abs(plus_array_lal), linestyle='dashed', label='lalsim')
ax.legend()
ax.set_title(r'Amplitude $h_{+}$')
ax.set_xlabel(r'$f$(Hz)')
ax.set_ylabel(r'$|h_{+}(f)|$')
fig.tight_layout()
fig.savefig('amplitude_plus.png')

fig, ax = plt.subplots()
hplus_phase_ti = np.where(np.abs(wf_array_ti['hplus'])>0.0, (wf_array_ti['hplus']/np.abs(wf_array_ti['hplus'])).real, 0.0)
hplus_phase_lal = np.where(np.abs(plus_array_lal)>0.0, (plus_array_lal/np.abs(plus_array_lal)).real, 0.0)
ax.semilogx(f_array, hplus_phase_ti, label='wf4ti')
ax.semilogx(f_array, hplus_phase_lal, linestyle='dashed', label='lalsim')
ax.legend()
ax.set_title(r'$\cos\Phi_+$')
ax.set_xlabel(r'$f$(Hz)')
ax.set_ylabel(r'$\cos\Phi_{+}$')
fig.savefig('cos_phase_plus.png')

# difference
# amplitude cross
fig, ax = plt.subplots()
ax.loglog(f_array, np.abs(np.abs(wf_array_ti['hcross'])-np.abs(cross_array_lal))/np.abs(cross_array_lal), linestyle='', marker='.', markersize=5)
ax.set_title('Amplitude difference cross')
ax.set_xlabel(r'$f$(Hz)')
ax.set_ylabel(r'$|\frac{|h^{\rm ti}_\times| - |h^{\rm lal}_\times|}{|h^{\rm lal}_\times|}|$')
fig.savefig('amplitude_cross_diff.png')
# amplitude plus
fig, ax = plt.subplots()
ax.loglog(f_array, np.abs(np.abs(wf_array_ti['hplus'])-np.abs(plus_array_lal))/np.abs(plus_array_lal), linestyle='', marker='.', markersize=5)
ax.set_title('Amplitude difference plus')
ax.set_xlabel(r'$f$(Hz)')
ax.set_ylabel(r'$|\frac{|h^{\rm ti}_+| - |h^{\rm lal}_+|}{|h^{\rm lal}_+|}|$')
fig.savefig('amplitude_plus_diff.png')
# phase cross
fig, ax = plt.subplots()
hcross_phase_ti = np.where(np.abs(wf_array_ti['hcross'])>0.0, (wf_array_ti['hcross']/np.abs(wf_array_ti['hcross'])).real, 0.0)
hcross_phase_lal = np.where(np.abs(cross_array_lal)>0.0, (cross_array_lal/np.abs(cross_array_lal)).real, 0.0)
ax.loglog(f_array, np.abs((hcross_phase_ti-hcross_phase_lal)/hcross_phase_lal), linestyle='', marker='.', markersize=5)
ax.set_title('Phase difference cross')
ax.set_xlabel(r'$f$(Hz)')
ax.set_ylabel(r'$|\frac{\cos\Phi^{\rm ti}_{\times}-\cos\Phi^{\rm lal}_{\times}}{\cos\Phi^{\rm lal}_{\times}}|$')
fig.savefig('cos_phase_cross_diff.png')
# phase plus
fig, ax = plt.subplots()
hplus_phase_ti = np.where(np.abs(wf_array_ti['hplus'])>0.0, (wf_array_ti['hplus']/np.abs(wf_array_ti['hplus'])).real, 0.0)
hplus_phase_lal = np.where(np.abs(plus_array_lal)>0.0, (plus_array_lal/np.abs(plus_array_lal)).real, 0.0)
ax.loglog(f_array, np.abs((hplus_phase_ti-hplus_phase_lal)/hplus_phase_lal), linestyle='', marker='.', markersize=5)
ax.set_title('Phase difference plus')
ax.set_xlabel(r'$f$(Hz)')
ax.set_ylabel(r'$|\frac{\cos\Phi^{\rm ti}_{+}-\cos\Phi^{\rm lal}_{+}}{\cos\Phi^{\rm lal}_{+}}|$')
fig.savefig('cos_phase_plus_diff.png')

####################################################################################################
# comparing the amplitude and phase with wf4py
sys.path.append('/home/hydrogen/gw_software/WF4Py-master')
from WF4Py import waveforms as wf_py

# generating amplitude and phase with wf4ti
wf_amp_phase = IMRPhenomD(frequencies, returned_form='amplitude_phase')
wf_amp_phase.get_waveform(parameters)
wf_amp_phase_array_ti = wf_amp_phase.np_array_of_waveform_container()
# generating amplitude and phase with wf4py
parameters = bilby.gw.conversion.generate_all_bbh_parameters(parameters)
params_wf4py = {'Mc'    : np.asarray(parameters['chirp_mass']),
                'eta'   : np.asarray(parameters['symmetric_mass_ratio']),
                'chi1z' : np.asarray(parameters['chi_1']),
                'chi2z' : np.asarray(parameters['chi_2']),
                'iota'  : np.asarray(parameters['inclination']),
                'dL'    : np.asarray(parameters['luminosity_distance']/1000)    # wf4py using the unit of Gpc
                }
wfclass_py = wf_py.IMRPhenomD()
amp_array_py = wfclass_py.Ampl(f_array, **params_wf4py)
phase_array_py = wfclass_py.Phi(f_array, **params_wf4py)

# visualizing
fig, ax = plt.subplots()
ax.loglog(f_array, wf_amp_phase_array_ti['amplitude'], label='wf4ti')
ax.loglog(f_array, amp_array_py, linestyle='dashed', label='wf4py')
ax.legend()
ax.set_title('Amplitude')
ax.set_xlabel(r'$f$(Hz)')
ax.set_ylabel(r'$|h(f)|$')
fig.savefig('amplitude_ti_py.png')

fig, ax = plt.subplots()
ax.semilogx(f_array, wf_amp_phase_array_ti['phase'], label='wf4ti')
ax.semilogx(f_array, phase_array_py, linestyle='dashed', label='wf4py')
ax.legend()
ax.set_title('Phase')
ax.set_xlabel(r'$f$(Hz)')
ax.set_ylabel(r'$phase$')
fig.savefig('phase_ti_py.png')

####################################################################################################
# comparing the amplituce_phase in lalsim
# this part requires the modified lalsuite (https://github.com/niuiniuin/lalsuite)
from lalsimulation import SimIMRPhenomDFrequencySequenceh22AmpPhasetf

# waveform generated by wf4ti
wf = IMRPhenomD(frequencies, returned_form='amplitude_phase')
wf.get_waveform(parameters)
f_peak = wf.amplitude_coefficients[None].f_peak
f_peak = f_peak/wf.source_parameters[None].M_sec
wf = IMRPhenomD(frequencies, returned_form='amplitude_phase', reference_frequency=f_peak)
wf.get_waveform(parameters)
wf_array_ti = wf.np_array_of_waveform_container()
# waveform generated by lalsim
extraParams = lal.CreateDict()
amp_lal, phase_lal, tf_lal = SimIMRPhenomDFrequencySequenceh22AmpPhasetf(f_array, 
                                                                         parameters['mass_1'], 
                                                                         parameters['mass_2'], 
                                                                         parameters['chi_1'], 
                                                                         parameters['chi_2'], 
                                                                         parameters['luminosity_distance'], 
                                                                         parameters['coalescence_time'], 
                                                                         0.0, 
                                                                         extraParams)
amp_array_lal = amp_lal.data
phase_array_lal = phase_lal.data
tf_array_lal = tf_lal.data

# visualizing
fig, ax = plt.subplots()
ax.loglog(f_array, wf_array_ti['amplitude'], label='wf4ti')
ax.loglog(f_array, amp_array_lal*2*np.sqrt(5/64/PI), linestyle='dashed', label='lalsim')    # note that the returned amplitude is for h22 in lal
ax.legend()
fig.savefig('amplitude_ti_lal.png')

fig, ax = plt.subplots()
ax.semilogx(f_array, wf_array_ti['phase'], label='wf4ti')
ax.semilogx(f_array, -phase_array_lal, linestyle='dashed', label='lalsim')
ax.legend()
fig.savefig('phase_ti_lal.png')

fig, ax = plt.subplots()
ax.semilogx(f_array, wf_array_ti['tf'], label='wf4ti')
ax.semilogx(f_array, tf_array_lal, linestyle='dashed', label='lalsim')
ax.legend()
fig.savefig('tf_ti_lal.png')


####################################################################################################
# comparing the amplituce, phase, tf in bbhx
from bbhx.waveforms.phenomhm import PhenomHMAmpPhase

# waveform generated by wf4ti
wf = IMRPhenomD(frequencies, returned_form='amplitude_phase')
wf.get_waveform(parameters)
f_peak = wf.amplitude_coefficients[None].f_peak
f_peak = f_peak/wf.source_parameters[None].M_sec
wf = IMRPhenomD(frequencies, returned_form='amplitude_phase', reference_frequency=f_peak)
wf.get_waveform(parameters)
wf_array_ti = wf.np_array_of_waveform_container()

# waveform generated by bbhx
bbhx_wf = PhenomHMAmpPhase(run_phenomd=True)
bbhx_wf(parameters['mass_1'],
        parameters['mass_2'],
        parameters['chi_1'],
        parameters['chi_2'],
        parameters['luminosity_distance']*1e6*PC_SI,
        parameters['reference_frequency'],
        f_peak,
        parameters['coalescence_time'],
        data_length,
        freqs=f_array)
amps_bbhx = bbhx_wf.amp[0][0]  # shape (num_bin_all, num_modes, length)
phase_bbhx = bbhx_wf.phase[0][0]  # shape (num_bin_all, num_modes, length)
tf_bbhx = bbhx_wf.tf[0][0]

# visualizing
fig, ax = plt.subplots()
ax.loglog(f_array, wf_array_ti['amplitude'], label='wf4ti')
ax.loglog(f_array, amps_bbhx*2*np.sqrt(5/64/PI), linestyle='dashed', label='bbhx')    # note that the returned amplitude is for h22 in lal
ax.legend()
fig.savefig('amplitude_ti_bbhx.png')

fig, ax = plt.subplots()
ax.semilogx(f_array, wf_array_ti['phase'], label='wf4ti')
ax.semilogx(f_array, phase_bbhx, linestyle='dashed', label='bbhx')
ax.legend()
fig.savefig('phase_ti_bbhx.png')

fig, ax = plt.subplots()
ax.semilogx(f_array, wf_array_ti['tf'], label='wf4ti')
ax.semilogx(f_array, tf_bbhx, linestyle='dashed', label='bbhx')
ax.legend()
fig.savefig('tf_ti_bbhx.png')

####################################################################################################
# tf and derivated phase
parameters['coalescence_time'] = 0.0

wf = IMRPhenomD(frequencies, returned_form='amplitude_phase')
wf.get_waveform(parameters)
wf_array_ti = wf.np_array_of_waveform_container()
dphase = (wf_array_ti['phase'][1:] -  wf_array_ti['phase'][:-1]) * duration / 2 / PI

amp_lal, phase_lal, tf_lal = SimIMRPhenomDFrequencySequenceh22AmpPhasetf(f_array, 
                                                                         parameters['mass_1'], 
                                                                         parameters['mass_2'], 
                                                                         parameters['chi_1'], 
                                                                         parameters['chi_2'], 
                                                                         parameters['luminosity_distance'], 
                                                                         parameters['coalescence_time'], 
                                                                         0.0, 
                                                                         extraParams)
amp_array_lal = amp_lal.data
phase_array_lal = phase_lal.data
tf_array_lal = tf_lal.data

fig, ax = plt.subplots()
ax.loglog(f_array[:-1], np.abs(dphase), label=r'dphase\_ti')
ax.loglog(f_array, np.abs(wf_array_ti['tf']), linestyle='dashed', label=r'tf\_ti')
ax.loglog(f_array, np.abs(tf_array_lal), linestyle='dotted', label='lalsim')
ax.axvline(wf.amplitude_coefficients[None].f_peak/wf.source_parameters[None].M_sec, color='tab:red', label='fpeak')
ax.set_xlabel(r'$f$(Hz)')
ax.set_ylabel(r'$t(f)$')
ax.legend()
fig.savefig('tf_dphase.png')
