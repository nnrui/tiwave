import sys 
import time
import os
os.environ[
    "XLA_FLAGS"
] = "--xla_cpu_multi_thread_eigen=false  --xla_force_host_platform_device_count=1 intra_op_parallelism_threads=1"
os.environ["OPENBLAS_NUM_THREADS"] = "1"
os.environ["MKL_NUM_THREADS"] = "1"
os.environ["OMP_NUM_THREAD"] = "1"

import numpy as np
from matplotlib import pyplot as plt
import pandas as pd

import lal
import lalsimulation as lalsim
from lalsimulation import SimInspiralChooseFDWaveformSequence
import bilby

sys.path.append('/home/hydrogen/workspace/Space_GW/wf4ti')
from wf4ti.waveforms.IMRPhenomD import IMRPhenomD as ti_IMRPhenomD
from wf4ti.constants import *
import taichi as ti
ti.init(arch=ti.cpu, default_fp=ti.f64, cpu_max_num_threads=1)
# ti.init(arch=ti.gpu, default_fp=ti.f64)

sys.path.append('/home/hydrogen/gw_software/WF4Py-master')
from WF4Py import waveforms as wf_py

sys.path.append('/home/hydrogen/gw_software/ripple-main/src')
import jax
import jax.numpy as jnp
jax.config.update("jax_enable_x64", True)
jax.config.update('jax_platform_name', 'cpu')
x = jnp.square(2)
print(repr(x.device_buffer.device()))
print(jax.devices())
print(jax.local_device_count())
from ripple.waveforms import IMRPhenomD


num_tests = 10
rng = np.random.default_rng()
parameters = {}
parameters['total_mass'] = rng.uniform(1e5, 1e6, num_tests)
parameters['mass_ratio'] = rng.uniform(0.2, 1.0, num_tests)
parameters['chi_1'] = rng.uniform(-1.0, 1.0, num_tests)
parameters['chi_2'] = rng.uniform(-1.0, 1.0, num_tests)
parameters['luminosity_distance'] = rng.uniform(1000.0, 10000.0, num_tests)
parameters['inclination'] = rng.uniform(0, np.pi, num_tests)
parameters['reference_phase'] = rng.uniform(0, 2*np.pi, num_tests)
parameters['coalescence_time'] = np.zeros(num_tests)
parameters = bilby.gw.conversion.generate_mass_parameters(parameters)
parameters = pd.DataFrame(parameters)
# print(parameters.keys())
# print(parameters)
# for i in range(num_tests):
#     params = parameters.iloc[i]
#     fpeak = lalsim.IMRPhenomDGetPeakFreq(params['mass_1'],
#                                          params['mass_2'],
#                                          params['chi_1'],
#                                          params['chi_2'])
#     print(f'total mass: {params["total_mass"]}, peak frequency: {fpeak}')


extraParams = lal.CreateDict()
approximant = lalsim.GetApproximantFromString('IMRPhenomD')

minimum_frequency = 1e-5
maximum_frequency = 1e-1

time_consuming_ti = []
time_consuming_lal = []
time_consuming_py = []
time_consuming_ripple = []
time_consuming_bbhx = []


# NOTE: since different codes has different output form, some output amplitude and phase, 
# some output polarizations, the comparison maybe not absolutely fair.
# The output of wf4ti includes polarizations and tf which could be thought having the most 
# compution steps.
for p in range(10, 30):
# for p in range(10, 12):
    duration = 2**p
    cadance = 10
    f_array = np.arange(0, 1.0/(2*cadance), 1.0/duration)
    bound = ((f_array >= minimum_frequency) * (f_array <= maximum_frequency))
    f_array = f_array[bound]
    data_length = len(f_array)

    # ##########################################################################################
    # # waveform generated by wf4ti
    # frequencies = ti.field(ti.f64, shape=(data_length,))
    # frequencies.from_numpy(f_array)
    # wf = ti_IMRPhenomD(frequencies, returned_form='polarizations', include_tf=True)
    # wf.get_waveform(parameters.iloc[0])
    
    # st = time.perf_counter()
    # for i in range(num_tests):
    #     wf.get_waveform(parameters.iloc[i])
    # ed = time.perf_counter()
    # time_consuming = (ed - st)/num_tests
    # print(f'ti {p}th, time:{time_consuming}')
    # time_consuming_ti.append(time_consuming)
    # ##########################################################################################
    # # waveform generated by lalsim
    # # remember export OMP_NUM_THREADS=1
    # f_array_lal = lal.CreateREAL8Vector(data_length)
    # f_array_lal.data = f_array

    # st = time.perf_counter()
    # for i in range(num_tests):
    #     plus_lal, cross_lal = SimInspiralChooseFDWaveformSequence(parameters.iloc[i]['reference_phase'], 
    #                                                               parameters.iloc[i]['mass_1']*MSUN_SI, 
    #                                                               parameters.iloc[i]['mass_2']*MSUN_SI, 
    #                                                               0.0,
    #                                                               0.0,
    #                                                               parameters.iloc[i]['chi_1'], 
    #                                                               0.0,
    #                                                               0.0,
    #                                                               parameters.iloc[i]['chi_2'], 
    #                                                               0.0,
    #                                                               parameters.iloc[i]['luminosity_distance']*1e6*PC_SI,
    #                                                               parameters.iloc[i]['inclination'],
    #                                                               extraParams, 
    #                                                               approximant,
    #                                                               f_array_lal
    #                                                               )
    # ed = time.perf_counter()
    # time_consuming = (ed - st)/num_tests
    # print(f'lalsim {p}th, time:{time_consuming}')
    # time_consuming_lal.append(time_consuming)
    # ##########################################################################################
    # # waveform generated by wf4py
    # wfclass_py = wf_py.IMRPhenomD()
    # st = time.perf_counter()
    # for i in range(num_tests):
    #     params_wf4py = {'Mc'    : np.asarray(parameters.iloc[i]['chirp_mass']),
    #                     'eta'   : np.asarray(parameters.iloc[i]['symmetric_mass_ratio']),
    #                     'chi1z' : np.asarray(parameters.iloc[i]['chi_1']),
    #                     'chi2z' : np.asarray(parameters.iloc[i]['chi_2']),
    #                     'iota'  : np.asarray(parameters.iloc[i]['inclination']),
    #                     'dL'    : np.asarray(parameters.iloc[i]['luminosity_distance'])/1000    # wf4py using the unit of Gpc
    #                     }
    #     amp_array_py = wfclass_py.Ampl(f_array, **params_wf4py)
    #     phase_array_py = wfclass_py.Phi(f_array, **params_wf4py)
    #     tf_array_py = wfclass_py.tau_star(f_array, **params_wf4py)
    # ed = time.perf_counter()
    # time_consuming = (ed - st)/num_tests
    # print(f'py {p}th, time:{time_consuming}')
    # time_consuming_py.append(time_consuming)
    ##########################################################################################
    # waveform generated by ripple
    f_jnp_array = jnp.asarray(f_array)
    print(f_jnp_array.shape)
    @jax.jit
    def waveform_ripple(theta):
        return IMRPhenomD.gen_IMRPhenomD_hphc(f_jnp_array, theta, f_jnp_array[0])
    
    st = time.perf_counter()
    for i in range(num_tests):
        theta_ripple = jnp.array([parameters.iloc[i]['chirp_mass'],
                                  parameters.iloc[i]['symmetric_mass_ratio'],
                                  parameters.iloc[i]['chi_1'],
                                  parameters.iloc[i]['chi_2'],
                                  parameters.iloc[i]['luminosity_distance'],
                                  parameters.iloc[i]['coalescence_time'],
                                  parameters.iloc[i]['reference_phase'],
                                  parameters.iloc[i]['inclination']
                                  ])
        hp, hc = waveform_ripple(theta_ripple)
    ed = time.perf_counter()
    time_consuming = (ed - st)/num_tests
    print(f'ripple {p}th, time:{time_consuming}')
    time_consuming_ripple.append(time_consuming)

    ##########################################################################################
    # waveform generated by bbhx

# plt.figure()
# plt.plot(range(20), time_consuming_ti, label='ti')
# plt.plot(range(20), time_consuming_lal, label='lal')
# plt.legend()
# plt.savefig('perf_comparing_cpu.png')
